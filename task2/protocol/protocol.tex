\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[usenames,dvipsnames]{color}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{Gray}{gray}{0.5}

\lstset{
    language=Java,
    basicstyle=\ttfamily,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
}

\title{VU Advanced Multiprocessor Programming \\
       SS 2013 \\
       Task 2}
\author{Jakob Gruber, 0203440 \\
        Martin Kalany, 0123456}

\begin{document}

\maketitle

\tableofcontents

\pagebreak

\section{Specifications}

\begin{comment}
* Good theoretical analysis (invariants, linearizability, progress guarantees).
* Good benchmark analysis.
* Short document: 2-4 pages excluding plots and sourcecode. Description of data
  structure. Theoretical analysis. Benchmark (results, process).

A couple of notes:

Remove doesn't compact the set. In fact, I think it's impossible to *know* when
a compaction is possible since it depends on the hash functions.

The refined set does not delete old mutex collections until the set is deleted.
This results in a little memory overhead but is necessary because we can't
simply delete old lock sets (other threads might still be accessing them). We
tried reference counting, but it ended up as the bottleneck for >~4 threads.

For the same reason (= no garbage collection), we also had to introduce a
global lock in relocate() to protect ProbeSets from being deleted while still
in use.

The Go implementation doesn't need either of these crutches. It's also designed
to work without reentrant locks and thread ids.
\end{comment}

\end{document}
